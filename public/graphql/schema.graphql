"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Bond`."""
  bonds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Bond`."""
    orderBy: [BondsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondFilter
  ): BondsConnection

  """Reads and enables pagination through a set of `BondAlpha`."""
  bondAlphas(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondAlpha`."""
    orderBy: [BondAlphasOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondAlphaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondAlphaFilter
  ): BondAlphasConnection

  """Reads and enables pagination through a set of `BondBuy`."""
  bondBuys(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondBuy`."""
    orderBy: [BondBuysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondBuyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondBuyFilter
  ): BondBuysConnection

  """Reads and enables pagination through a set of `BondSell`."""
  bondSells(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondSell`."""
    orderBy: [BondSellsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondSellCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondSellFilter
  ): BondSellsConnection

  """Reads and enables pagination through a set of `BondSwap`."""
  bondSwaps(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondSwap`."""
    orderBy: [BondSwapsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondSwapCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondSwapFilter
  ): BondSwapsConnection

  """Reads and enables pagination through a set of `Chain`."""
  chains(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Chain`."""
    orderBy: [ChainsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChainCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ChainFilter
  ): ChainsConnection

  """Reads and enables pagination through a set of `Claim`."""
  claims(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Claim`."""
    orderBy: [ClaimsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClaimCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClaimFilter
  ): ClaimsConnection

  """Reads and enables pagination through a set of `ClaimCollection`."""
  claimCollections(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ClaimCollection`."""
    orderBy: [ClaimCollectionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClaimCollectionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClaimCollectionFilter
  ): ClaimCollectionsConnection

  """Reads and enables pagination through a set of `Dispute`."""
  disputes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Dispute`."""
    orderBy: [DisputesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DisputeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DisputeFilter
  ): DisputesConnection

  """Reads and enables pagination through a set of `Entity`."""
  entities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Entity`."""
    orderBy: [EntitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntityFilter
  ): EntitiesConnection

  """Reads and enables pagination through a set of `Evaluation`."""
  evaluations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Evaluation`."""
    orderBy: [EvaluationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvaluationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvaluationFilter
  ): EvaluationsConnection

  """Reads and enables pagination through a set of `Iid`."""
  iids(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Iid`."""
    orderBy: [IidsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: IidCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IidFilter
  ): IidsConnection

  """Reads and enables pagination through a set of `Ipf`."""
  ipfs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ipf`."""
    orderBy: [IpfsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: IpfCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IpfFilter
  ): IpfsConnection

  """Reads and enables pagination through a set of `Message`."""
  messages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MessageFilter
  ): MessagesConnection

  """Reads and enables pagination through a set of `OutcomePayment`."""
  outcomePayments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `OutcomePayment`."""
    orderBy: [OutcomePaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutcomePaymentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutcomePaymentFilter
  ): OutcomePaymentsConnection

  """Reads and enables pagination through a set of `ReserveWithdrawal`."""
  reserveWithdrawals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ReserveWithdrawal`."""
    orderBy: [ReserveWithdrawalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReserveWithdrawalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReserveWithdrawalFilter
  ): ReserveWithdrawalsConnection

  """Reads and enables pagination through a set of `ShareWithdrawal`."""
  shareWithdrawals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ShareWithdrawal`."""
    orderBy: [ShareWithdrawalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ShareWithdrawalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ShareWithdrawalFilter
  ): ShareWithdrawalsConnection

  """Reads and enables pagination through a set of `Token`."""
  tokens(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Token`."""
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenFilter
  ): TokensConnection

  """Reads and enables pagination through a set of `TokenCancelled`."""
  tokenCancelleds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenCancelled`."""
    orderBy: [TokenCancelledsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenCancelledCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenCancelledFilter
  ): TokenCancelledsConnection

  """Reads and enables pagination through a set of `TokenClass`."""
  tokenClasses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenClass`."""
    orderBy: [TokenClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenClassCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenClassFilter
  ): TokenClassesConnection

  """Reads and enables pagination through a set of `TokenDatum`."""
  tokenData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenDatum`."""
    orderBy: [TokenDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenDatumFilter
  ): TokenDataConnection

  """Reads and enables pagination through a set of `TokenRetired`."""
  tokenRetireds(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenRetired`."""
    orderBy: [TokenRetiredsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenRetiredCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenRetiredFilter
  ): TokenRetiredsConnection

  """Reads and enables pagination through a set of `TokenTransaction`."""
  tokenTransactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenTransaction`."""
    orderBy: [TokenTransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenTransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenTransactionFilter
  ): TokenTransactionsConnection

  """Reads and enables pagination through a set of `Transaction`."""
  transactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter
  ): TransactionsConnection

  """Reads and enables pagination through a set of `_PrismaMigration`."""
  _prismaMigrations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: _PrismaMigrationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: _PrismaMigrationFilter
  ): _PrismaMigrationsConnection
  bond(bondDid: String!): Bond
  bondAlpha(id: Int!): BondAlpha
  bondBuy(id: Int!): BondBuy
  bondSell(id: Int!): BondSell
  bondSwap(id: Int!): BondSwap
  chain(chainId: String!): Chain
  claim(claimId: String!): Claim
  claimCollection(id: String!): ClaimCollection
  dispute(proof: String!): Dispute
  entity(id: String!): Entity
  evaluation(claimId: String!): Evaluation
  iid(id: String!): Iid
  ipf(cid: String!): Ipf
  message(id: Int!): Message
  outcomePayment(id: Int!): OutcomePayment
  reserveWithdrawal(id: Int!): ReserveWithdrawal
  shareWithdrawal(id: Int!): ShareWithdrawal
  token(id: String!): Token
  tokenCancelled(aid: Int!): TokenCancelled
  tokenClass(contractAddress: String!): TokenClass
  tokenDatum(aid: Int!): TokenDatum
  tokenRetired(aid: Int!): TokenRetired
  tokenTransaction(aid: Int!): TokenTransaction
  transaction(hash: String!): Transaction
  _prismaMigration(id: String!): _PrismaMigration

  """Reads a single `Bond` using its globally unique `ID`."""
  bondByNodeId(
    """The globally unique `ID` to be used in selecting a single `Bond`."""
    nodeId: ID!
  ): Bond

  """Reads a single `BondAlpha` using its globally unique `ID`."""
  bondAlphaByNodeId(
    """The globally unique `ID` to be used in selecting a single `BondAlpha`."""
    nodeId: ID!
  ): BondAlpha

  """Reads a single `BondBuy` using its globally unique `ID`."""
  bondBuyByNodeId(
    """The globally unique `ID` to be used in selecting a single `BondBuy`."""
    nodeId: ID!
  ): BondBuy

  """Reads a single `BondSell` using its globally unique `ID`."""
  bondSellByNodeId(
    """The globally unique `ID` to be used in selecting a single `BondSell`."""
    nodeId: ID!
  ): BondSell

  """Reads a single `BondSwap` using its globally unique `ID`."""
  bondSwapByNodeId(
    """The globally unique `ID` to be used in selecting a single `BondSwap`."""
    nodeId: ID!
  ): BondSwap

  """Reads a single `Chain` using its globally unique `ID`."""
  chainByNodeId(
    """The globally unique `ID` to be used in selecting a single `Chain`."""
    nodeId: ID!
  ): Chain

  """Reads a single `Claim` using its globally unique `ID`."""
  claimByNodeId(
    """The globally unique `ID` to be used in selecting a single `Claim`."""
    nodeId: ID!
  ): Claim

  """Reads a single `ClaimCollection` using its globally unique `ID`."""
  claimCollectionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ClaimCollection`.
    """
    nodeId: ID!
  ): ClaimCollection

  """Reads a single `Dispute` using its globally unique `ID`."""
  disputeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Dispute`."""
    nodeId: ID!
  ): Dispute

  """Reads a single `Entity` using its globally unique `ID`."""
  entityByNodeId(
    """The globally unique `ID` to be used in selecting a single `Entity`."""
    nodeId: ID!
  ): Entity

  """Reads a single `Evaluation` using its globally unique `ID`."""
  evaluationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Evaluation`.
    """
    nodeId: ID!
  ): Evaluation

  """Reads a single `Iid` using its globally unique `ID`."""
  iidByNodeId(
    """The globally unique `ID` to be used in selecting a single `Iid`."""
    nodeId: ID!
  ): Iid

  """Reads a single `Ipf` using its globally unique `ID`."""
  ipfByNodeId(
    """The globally unique `ID` to be used in selecting a single `Ipf`."""
    nodeId: ID!
  ): Ipf

  """Reads a single `Message` using its globally unique `ID`."""
  messageByNodeId(
    """The globally unique `ID` to be used in selecting a single `Message`."""
    nodeId: ID!
  ): Message

  """Reads a single `OutcomePayment` using its globally unique `ID`."""
  outcomePaymentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `OutcomePayment`.
    """
    nodeId: ID!
  ): OutcomePayment

  """Reads a single `ReserveWithdrawal` using its globally unique `ID`."""
  reserveWithdrawalByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ReserveWithdrawal`.
    """
    nodeId: ID!
  ): ReserveWithdrawal

  """Reads a single `ShareWithdrawal` using its globally unique `ID`."""
  shareWithdrawalByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ShareWithdrawal`.
    """
    nodeId: ID!
  ): ShareWithdrawal

  """Reads a single `Token` using its globally unique `ID`."""
  tokenByNodeId(
    """The globally unique `ID` to be used in selecting a single `Token`."""
    nodeId: ID!
  ): Token

  """Reads a single `TokenCancelled` using its globally unique `ID`."""
  tokenCancelledByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TokenCancelled`.
    """
    nodeId: ID!
  ): TokenCancelled

  """Reads a single `TokenClass` using its globally unique `ID`."""
  tokenClassByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TokenClass`.
    """
    nodeId: ID!
  ): TokenClass

  """Reads a single `TokenDatum` using its globally unique `ID`."""
  tokenDatumByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TokenDatum`.
    """
    nodeId: ID!
  ): TokenDatum

  """Reads a single `TokenRetired` using its globally unique `ID`."""
  tokenRetiredByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TokenRetired`.
    """
    nodeId: ID!
  ): TokenRetired

  """Reads a single `TokenTransaction` using its globally unique `ID`."""
  tokenTransactionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TokenTransaction`.
    """
    nodeId: ID!
  ): TokenTransaction

  """Reads a single `Transaction` using its globally unique `ID`."""
  transactionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Transaction`.
    """
    nodeId: ID!
  ): Transaction

  """Reads a single `_PrismaMigration` using its globally unique `ID`."""
  _prismaMigrationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `_PrismaMigration`.
    """
    nodeId: ID!
  ): _PrismaMigration
  getAccountTokens(address: String!, name: String): JSON!
  getTokensTotalByAddress(address: String!, name: String): JSON!
  getTokensTotalForEntities(address: String!, name: String): JSON!
  getTokensTotalForCollection(did: String!, name: String): JSON!
  getTokensTotalForCollectionAmounts(did: String!, name: String): JSON!
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Bond` values."""
type BondsConnection {
  """A list of `Bond` objects."""
  nodes: [Bond!]!

  """
  A list of edges which contains the `Bond` and cursor to aid in pagination.
  """
  edges: [BondsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Bond` you could get from the connection."""
  totalCount: Int!
}

type Bond implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  bondDid: String!
  state: String!
  token: String!
  name: String!
  description: String!
  functionType: String!
  functionParameters: [JSON]
  creatorDid: String!
  controllerDid: String!
  reserveTokens: [String]
  txFeePercentage: String!
  exitFeePercentage: String!
  feeAddress: String!
  reserveWithdrawalAddress: String!
  maxSupply: JSON
  orderQuantityLimits: [JSON]
  sanityRate: String!
  sanityMarginPercentage: String!
  currentSupply: JSON
  currentReserve: [JSON]
  availableReserve: [JSON]
  currentOutcomePaymentReserve: [JSON]
  allowSells: Boolean!
  allowReserveWithdrawals: Boolean!
  alphaBond: Boolean!
  batchBlocks: String!
  outcomePayment: String!
  oracleDid: String!

  """Reads and enables pagination through a set of `BondBuy`."""
  bondBuysByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondBuy`."""
    orderBy: [BondBuysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondBuyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondBuyFilter
  ): BondBuysConnection!

  """Reads and enables pagination through a set of `BondSell`."""
  bondSellsByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondSell`."""
    orderBy: [BondSellsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondSellCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondSellFilter
  ): BondSellsConnection!

  """Reads and enables pagination through a set of `BondSwap`."""
  bondSwapsByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondSwap`."""
    orderBy: [BondSwapsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondSwapCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondSwapFilter
  ): BondSwapsConnection!

  """Reads and enables pagination through a set of `ReserveWithdrawal`."""
  reserveWithdrawalsByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ReserveWithdrawal`."""
    orderBy: [ReserveWithdrawalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReserveWithdrawalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReserveWithdrawalFilter
  ): ReserveWithdrawalsConnection!

  """Reads and enables pagination through a set of `ShareWithdrawal`."""
  shareWithdrawalsByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ShareWithdrawal`."""
    orderBy: [ShareWithdrawalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ShareWithdrawalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ShareWithdrawalFilter
  ): ShareWithdrawalsConnection!

  """Reads and enables pagination through a set of `OutcomePayment`."""
  outcomePaymentsByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `OutcomePayment`."""
    orderBy: [OutcomePaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutcomePaymentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutcomePaymentFilter
  ): OutcomePaymentsConnection!

  """Reads and enables pagination through a set of `BondAlpha`."""
  bondAlphasByBondDid(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BondAlpha`."""
    orderBy: [BondAlphasOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BondAlphaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BondAlphaFilter
  ): BondAlphasConnection!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A connection to a list of `BondBuy` values."""
type BondBuysConnection {
  """A list of `BondBuy` objects."""
  nodes: [BondBuy!]!

  """
  A list of edges which contains the `BondBuy` and cursor to aid in pagination.
  """
  edges: [BondBuysEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BondBuy` you could get from the connection."""
  totalCount: Int!
}

type BondBuy implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  accountDid: String!
  amount: JSON!
  maxPrices: [JSON]
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `BondBuy`."""
  bondByBondDid: Bond
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A `BondBuy` edge in the connection."""
type BondBuysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BondBuy` at the end of the edge."""
  node: BondBuy!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `BondBuy`."""
enum BondBuysOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  ACCOUNT_DID_ASC
  ACCOUNT_DID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  MAX_PRICES_ASC
  MAX_PRICES_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BondBuy` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BondBuyCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `accountDid` field."""
  accountDid: String

  """Checks for equality with the object’s `amount` field."""
  amount: JSON

  """Checks for equality with the object’s `maxPrices` field."""
  maxPrices: [JSON]

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""
A filter to be used against `BondBuy` object types. All fields are combined with a logical ‘and.’
"""
input BondBuyFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `accountDid` field."""
  accountDid: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONFilter

  """Filter by the object’s `maxPrices` field."""
  maxPrices: JSONListFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [BondBuyFilter!]

  """Checks for any expressions in this list."""
  or: [BondBuyFilter!]

  """Negates the expression."""
  not: BondBuyFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Included in the specified list."""
  in: [JSON!]

  """Not included in the specified list."""
  notIn: [JSON!]

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains the specified key."""
  containsKey: String

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contained by the specified JSON."""
  containedBy: JSON
}

"""
A filter to be used against JSON List fields. All fields are combined with a logical ‘and.’
"""
input JSONListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [JSON]

  """Not equal to the specified value."""
  notEqualTo: [JSON]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [JSON]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [JSON]

  """Less than the specified value."""
  lessThan: [JSON]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [JSON]

  """Greater than the specified value."""
  greaterThan: [JSON]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [JSON]

  """Contains the specified list of values."""
  contains: [JSON]

  """Contained by the specified list of values."""
  containedBy: [JSON]

  """Overlaps the specified list of values."""
  overlaps: [JSON]

  """Any array item is equal to the specified value."""
  anyEqualTo: JSON

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: JSON

  """Any array item is less than the specified value."""
  anyLessThan: JSON

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: JSON

  """Any array item is greater than the specified value."""
  anyGreaterThan: JSON

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: JSON
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against `Bond` object types. All fields are combined with a logical ‘and.’
"""
input BondFilter {
  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `state` field."""
  state: StringFilter

  """Filter by the object’s `token` field."""
  token: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `functionType` field."""
  functionType: StringFilter

  """Filter by the object’s `functionParameters` field."""
  functionParameters: JSONListFilter

  """Filter by the object’s `creatorDid` field."""
  creatorDid: StringFilter

  """Filter by the object’s `controllerDid` field."""
  controllerDid: StringFilter

  """Filter by the object’s `reserveTokens` field."""
  reserveTokens: StringListFilter

  """Filter by the object’s `txFeePercentage` field."""
  txFeePercentage: StringFilter

  """Filter by the object’s `exitFeePercentage` field."""
  exitFeePercentage: StringFilter

  """Filter by the object’s `feeAddress` field."""
  feeAddress: StringFilter

  """Filter by the object’s `reserveWithdrawalAddress` field."""
  reserveWithdrawalAddress: StringFilter

  """Filter by the object’s `maxSupply` field."""
  maxSupply: JSONFilter

  """Filter by the object’s `orderQuantityLimits` field."""
  orderQuantityLimits: JSONListFilter

  """Filter by the object’s `sanityRate` field."""
  sanityRate: StringFilter

  """Filter by the object’s `sanityMarginPercentage` field."""
  sanityMarginPercentage: StringFilter

  """Filter by the object’s `currentSupply` field."""
  currentSupply: JSONFilter

  """Filter by the object’s `currentReserve` field."""
  currentReserve: JSONListFilter

  """Filter by the object’s `availableReserve` field."""
  availableReserve: JSONListFilter

  """Filter by the object’s `currentOutcomePaymentReserve` field."""
  currentOutcomePaymentReserve: JSONListFilter

  """Filter by the object’s `allowSells` field."""
  allowSells: BooleanFilter

  """Filter by the object’s `allowReserveWithdrawals` field."""
  allowReserveWithdrawals: BooleanFilter

  """Filter by the object’s `alphaBond` field."""
  alphaBond: BooleanFilter

  """Filter by the object’s `batchBlocks` field."""
  batchBlocks: StringFilter

  """Filter by the object’s `outcomePayment` field."""
  outcomePayment: StringFilter

  """Filter by the object’s `oracleDid` field."""
  oracleDid: StringFilter

  """Filter by the object’s `bondBuysByBondDid` relation."""
  bondBuysByBondDid: BondToManyBondBuyFilter

  """Some related `bondBuysByBondDid` exist."""
  bondBuysByBondDidExist: Boolean

  """Filter by the object’s `bondSellsByBondDid` relation."""
  bondSellsByBondDid: BondToManyBondSellFilter

  """Some related `bondSellsByBondDid` exist."""
  bondSellsByBondDidExist: Boolean

  """Filter by the object’s `bondSwapsByBondDid` relation."""
  bondSwapsByBondDid: BondToManyBondSwapFilter

  """Some related `bondSwapsByBondDid` exist."""
  bondSwapsByBondDidExist: Boolean

  """Filter by the object’s `reserveWithdrawalsByBondDid` relation."""
  reserveWithdrawalsByBondDid: BondToManyReserveWithdrawalFilter

  """Some related `reserveWithdrawalsByBondDid` exist."""
  reserveWithdrawalsByBondDidExist: Boolean

  """Filter by the object’s `shareWithdrawalsByBondDid` relation."""
  shareWithdrawalsByBondDid: BondToManyShareWithdrawalFilter

  """Some related `shareWithdrawalsByBondDid` exist."""
  shareWithdrawalsByBondDidExist: Boolean

  """Filter by the object’s `outcomePaymentsByBondDid` relation."""
  outcomePaymentsByBondDid: BondToManyOutcomePaymentFilter

  """Some related `outcomePaymentsByBondDid` exist."""
  outcomePaymentsByBondDidExist: Boolean

  """Filter by the object’s `bondAlphasByBondDid` relation."""
  bondAlphasByBondDid: BondToManyBondAlphaFilter

  """Some related `bondAlphasByBondDid` exist."""
  bondAlphasByBondDidExist: Boolean

  """Checks for all expressions in this list."""
  and: [BondFilter!]

  """Checks for any expressions in this list."""
  or: [BondFilter!]

  """Negates the expression."""
  not: BondFilter
}

"""
A filter to be used against String List fields. All fields are combined with a logical ‘and.’
"""
input StringListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """Contains the specified list of values."""
  contains: [String]

  """Contained by the specified list of values."""
  containedBy: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]

  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many `BondBuy` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyBondBuyFilter {
  """
  Every related `BondBuy` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BondBuyFilter

  """
  Some related `BondBuy` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BondBuyFilter

  """
  No related `BondBuy` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BondBuyFilter
}

"""
A filter to be used against many `BondSell` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyBondSellFilter {
  """
  Every related `BondSell` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BondSellFilter

  """
  Some related `BondSell` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BondSellFilter

  """
  No related `BondSell` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BondSellFilter
}

"""
A filter to be used against `BondSell` object types. All fields are combined with a logical ‘and.’
"""
input BondSellFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `accountDid` field."""
  accountDid: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [BondSellFilter!]

  """Checks for any expressions in this list."""
  or: [BondSellFilter!]

  """Negates the expression."""
  not: BondSellFilter
}

"""
A filter to be used against many `BondSwap` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyBondSwapFilter {
  """
  Every related `BondSwap` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BondSwapFilter

  """
  Some related `BondSwap` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BondSwapFilter

  """
  No related `BondSwap` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BondSwapFilter
}

"""
A filter to be used against `BondSwap` object types. All fields are combined with a logical ‘and.’
"""
input BondSwapFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `accountDid` field."""
  accountDid: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONFilter

  """Filter by the object’s `toToken` field."""
  toToken: StringFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [BondSwapFilter!]

  """Checks for any expressions in this list."""
  or: [BondSwapFilter!]

  """Negates the expression."""
  not: BondSwapFilter
}

"""
A filter to be used against many `ReserveWithdrawal` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyReserveWithdrawalFilter {
  """
  Every related `ReserveWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ReserveWithdrawalFilter

  """
  Some related `ReserveWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ReserveWithdrawalFilter

  """
  No related `ReserveWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ReserveWithdrawalFilter
}

"""
A filter to be used against `ReserveWithdrawal` object types. All fields are combined with a logical ‘and.’
"""
input ReserveWithdrawalFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `withdrawerDid` field."""
  withdrawerDid: StringFilter

  """Filter by the object’s `withdrawerAddress` field."""
  withdrawerAddress: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONListFilter

  """Filter by the object’s `reserveWithdrawalAddress` field."""
  reserveWithdrawalAddress: StringFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [ReserveWithdrawalFilter!]

  """Checks for any expressions in this list."""
  or: [ReserveWithdrawalFilter!]

  """Negates the expression."""
  not: ReserveWithdrawalFilter
}

"""
A filter to be used against many `ShareWithdrawal` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyShareWithdrawalFilter {
  """
  Every related `ShareWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ShareWithdrawalFilter

  """
  Some related `ShareWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ShareWithdrawalFilter

  """
  No related `ShareWithdrawal` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ShareWithdrawalFilter
}

"""
A filter to be used against `ShareWithdrawal` object types. All fields are combined with a logical ‘and.’
"""
input ShareWithdrawalFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `recipientDid` field."""
  recipientDid: StringFilter

  """Filter by the object’s `recipientAddress` field."""
  recipientAddress: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONListFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [ShareWithdrawalFilter!]

  """Checks for any expressions in this list."""
  or: [ShareWithdrawalFilter!]

  """Negates the expression."""
  not: ShareWithdrawalFilter
}

"""
A filter to be used against many `OutcomePayment` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyOutcomePaymentFilter {
  """
  Every related `OutcomePayment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OutcomePaymentFilter

  """
  Some related `OutcomePayment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OutcomePaymentFilter

  """
  No related `OutcomePayment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OutcomePaymentFilter
}

"""
A filter to be used against `OutcomePayment` object types. All fields are combined with a logical ‘and.’
"""
input OutcomePaymentFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `senderDid` field."""
  senderDid: StringFilter

  """Filter by the object’s `senderAddress` field."""
  senderAddress: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONListFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [OutcomePaymentFilter!]

  """Checks for any expressions in this list."""
  or: [OutcomePaymentFilter!]

  """Negates the expression."""
  not: OutcomePaymentFilter
}

"""
A filter to be used against many `BondAlpha` object types. All fields are combined with a logical ‘and.’
"""
input BondToManyBondAlphaFilter {
  """
  Every related `BondAlpha` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BondAlphaFilter

  """
  Some related `BondAlpha` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BondAlphaFilter

  """
  No related `BondAlpha` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BondAlphaFilter
}

"""
A filter to be used against `BondAlpha` object types. All fields are combined with a logical ‘and.’
"""
input BondAlphaFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `bondDid` field."""
  bondDid: StringFilter

  """Filter by the object’s `alpha` field."""
  alpha: StringFilter

  """Filter by the object’s `oracleDid` field."""
  oracleDid: StringFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `bondByBondDid` relation."""
  bondByBondDid: BondFilter

  """Checks for all expressions in this list."""
  and: [BondAlphaFilter!]

  """Checks for any expressions in this list."""
  or: [BondAlphaFilter!]

  """Negates the expression."""
  not: BondAlphaFilter
}

"""A connection to a list of `BondSell` values."""
type BondSellsConnection {
  """A list of `BondSell` objects."""
  nodes: [BondSell!]!

  """
  A list of edges which contains the `BondSell` and cursor to aid in pagination.
  """
  edges: [BondSellsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BondSell` you could get from the connection."""
  totalCount: Int!
}

type BondSell implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  accountDid: String!
  amount: JSON!
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `BondSell`."""
  bondByBondDid: Bond
}

"""A `BondSell` edge in the connection."""
type BondSellsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BondSell` at the end of the edge."""
  node: BondSell!
}

"""Methods to use when ordering `BondSell`."""
enum BondSellsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  ACCOUNT_DID_ASC
  ACCOUNT_DID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BondSell` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input BondSellCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `accountDid` field."""
  accountDid: String

  """Checks for equality with the object’s `amount` field."""
  amount: JSON

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A connection to a list of `BondSwap` values."""
type BondSwapsConnection {
  """A list of `BondSwap` objects."""
  nodes: [BondSwap!]!

  """
  A list of edges which contains the `BondSwap` and cursor to aid in pagination.
  """
  edges: [BondSwapsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BondSwap` you could get from the connection."""
  totalCount: Int!
}

type BondSwap implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  accountDid: String!
  amount: JSON!
  toToken: String!
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `BondSwap`."""
  bondByBondDid: Bond
}

"""A `BondSwap` edge in the connection."""
type BondSwapsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BondSwap` at the end of the edge."""
  node: BondSwap!
}

"""Methods to use when ordering `BondSwap`."""
enum BondSwapsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  ACCOUNT_DID_ASC
  ACCOUNT_DID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  TO_TOKEN_ASC
  TO_TOKEN_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BondSwap` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input BondSwapCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `accountDid` field."""
  accountDid: String

  """Checks for equality with the object’s `amount` field."""
  amount: JSON

  """Checks for equality with the object’s `toToken` field."""
  toToken: String

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A connection to a list of `ReserveWithdrawal` values."""
type ReserveWithdrawalsConnection {
  """A list of `ReserveWithdrawal` objects."""
  nodes: [ReserveWithdrawal!]!

  """
  A list of edges which contains the `ReserveWithdrawal` and cursor to aid in pagination.
  """
  edges: [ReserveWithdrawalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ReserveWithdrawal` you could get from the connection.
  """
  totalCount: Int!
}

type ReserveWithdrawal implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  withdrawerDid: String!
  withdrawerAddress: String!
  amount: [JSON]
  reserveWithdrawalAddress: String!
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `ReserveWithdrawal`."""
  bondByBondDid: Bond
}

"""A `ReserveWithdrawal` edge in the connection."""
type ReserveWithdrawalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ReserveWithdrawal` at the end of the edge."""
  node: ReserveWithdrawal!
}

"""Methods to use when ordering `ReserveWithdrawal`."""
enum ReserveWithdrawalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  WITHDRAWER_DID_ASC
  WITHDRAWER_DID_DESC
  WITHDRAWER_ADDRESS_ASC
  WITHDRAWER_ADDRESS_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  RESERVE_WITHDRAWAL_ADDRESS_ASC
  RESERVE_WITHDRAWAL_ADDRESS_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ReserveWithdrawal` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ReserveWithdrawalCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `withdrawerDid` field."""
  withdrawerDid: String

  """Checks for equality with the object’s `withdrawerAddress` field."""
  withdrawerAddress: String

  """Checks for equality with the object’s `amount` field."""
  amount: [JSON]

  """
  Checks for equality with the object’s `reserveWithdrawalAddress` field.
  """
  reserveWithdrawalAddress: String

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A connection to a list of `ShareWithdrawal` values."""
type ShareWithdrawalsConnection {
  """A list of `ShareWithdrawal` objects."""
  nodes: [ShareWithdrawal!]!

  """
  A list of edges which contains the `ShareWithdrawal` and cursor to aid in pagination.
  """
  edges: [ShareWithdrawalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ShareWithdrawal` you could get from the connection.
  """
  totalCount: Int!
}

type ShareWithdrawal implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  recipientDid: String!
  recipientAddress: String!
  amount: [JSON]
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `ShareWithdrawal`."""
  bondByBondDid: Bond
}

"""A `ShareWithdrawal` edge in the connection."""
type ShareWithdrawalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ShareWithdrawal` at the end of the edge."""
  node: ShareWithdrawal!
}

"""Methods to use when ordering `ShareWithdrawal`."""
enum ShareWithdrawalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  RECIPIENT_DID_ASC
  RECIPIENT_DID_DESC
  RECIPIENT_ADDRESS_ASC
  RECIPIENT_ADDRESS_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ShareWithdrawal` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ShareWithdrawalCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `recipientDid` field."""
  recipientDid: String

  """Checks for equality with the object’s `recipientAddress` field."""
  recipientAddress: String

  """Checks for equality with the object’s `amount` field."""
  amount: [JSON]

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A connection to a list of `OutcomePayment` values."""
type OutcomePaymentsConnection {
  """A list of `OutcomePayment` objects."""
  nodes: [OutcomePayment!]!

  """
  A list of edges which contains the `OutcomePayment` and cursor to aid in pagination.
  """
  edges: [OutcomePaymentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `OutcomePayment` you could get from the connection."""
  totalCount: Int!
}

type OutcomePayment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  senderDid: String!
  senderAddress: String!
  amount: [JSON]
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `OutcomePayment`."""
  bondByBondDid: Bond
}

"""A `OutcomePayment` edge in the connection."""
type OutcomePaymentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OutcomePayment` at the end of the edge."""
  node: OutcomePayment!
}

"""Methods to use when ordering `OutcomePayment`."""
enum OutcomePaymentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  SENDER_DID_ASC
  SENDER_DID_DESC
  SENDER_ADDRESS_ASC
  SENDER_ADDRESS_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `OutcomePayment` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OutcomePaymentCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `senderDid` field."""
  senderDid: String

  """Checks for equality with the object’s `senderAddress` field."""
  senderAddress: String

  """Checks for equality with the object’s `amount` field."""
  amount: [JSON]

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A connection to a list of `BondAlpha` values."""
type BondAlphasConnection {
  """A list of `BondAlpha` objects."""
  nodes: [BondAlpha!]!

  """
  A list of edges which contains the `BondAlpha` and cursor to aid in pagination.
  """
  edges: [BondAlphasEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BondAlpha` you could get from the connection."""
  totalCount: Int!
}

type BondAlpha implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bondDid: String!
  alpha: String!
  oracleDid: String!
  height: Int!
  timestamp: Datetime!

  """Reads a single `Bond` that is related to this `BondAlpha`."""
  bondByBondDid: Bond
}

"""A `BondAlpha` edge in the connection."""
type BondAlphasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BondAlpha` at the end of the edge."""
  node: BondAlpha!
}

"""Methods to use when ordering `BondAlpha`."""
enum BondAlphasOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BOND_DID_ASC
  BOND_DID_DESC
  ALPHA_ASC
  ALPHA_DESC
  ORACLE_DID_ASC
  ORACLE_DID_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BondAlpha` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input BondAlphaCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `alpha` field."""
  alpha: String

  """Checks for equality with the object’s `oracleDid` field."""
  oracleDid: String

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime
}

"""A `Bond` edge in the connection."""
type BondsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Bond` at the end of the edge."""
  node: Bond!
}

"""Methods to use when ordering `Bond`."""
enum BondsOrderBy {
  NATURAL
  BOND_DID_ASC
  BOND_DID_DESC
  STATE_ASC
  STATE_DESC
  TOKEN_ASC
  TOKEN_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FUNCTION_TYPE_ASC
  FUNCTION_TYPE_DESC
  FUNCTION_PARAMETERS_ASC
  FUNCTION_PARAMETERS_DESC
  CREATOR_DID_ASC
  CREATOR_DID_DESC
  CONTROLLER_DID_ASC
  CONTROLLER_DID_DESC
  RESERVE_TOKENS_ASC
  RESERVE_TOKENS_DESC
  TX_FEE_PERCENTAGE_ASC
  TX_FEE_PERCENTAGE_DESC
  EXIT_FEE_PERCENTAGE_ASC
  EXIT_FEE_PERCENTAGE_DESC
  FEE_ADDRESS_ASC
  FEE_ADDRESS_DESC
  RESERVE_WITHDRAWAL_ADDRESS_ASC
  RESERVE_WITHDRAWAL_ADDRESS_DESC
  MAX_SUPPLY_ASC
  MAX_SUPPLY_DESC
  ORDER_QUANTITY_LIMITS_ASC
  ORDER_QUANTITY_LIMITS_DESC
  SANITY_RATE_ASC
  SANITY_RATE_DESC
  SANITY_MARGIN_PERCENTAGE_ASC
  SANITY_MARGIN_PERCENTAGE_DESC
  CURRENT_SUPPLY_ASC
  CURRENT_SUPPLY_DESC
  CURRENT_RESERVE_ASC
  CURRENT_RESERVE_DESC
  AVAILABLE_RESERVE_ASC
  AVAILABLE_RESERVE_DESC
  CURRENT_OUTCOME_PAYMENT_RESERVE_ASC
  CURRENT_OUTCOME_PAYMENT_RESERVE_DESC
  ALLOW_SELLS_ASC
  ALLOW_SELLS_DESC
  ALLOW_RESERVE_WITHDRAWALS_ASC
  ALLOW_RESERVE_WITHDRAWALS_DESC
  ALPHA_BOND_ASC
  ALPHA_BOND_DESC
  BATCH_BLOCKS_ASC
  BATCH_BLOCKS_DESC
  OUTCOME_PAYMENT_ASC
  OUTCOME_PAYMENT_DESC
  ORACLE_DID_ASC
  ORACLE_DID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Bond` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BondCondition {
  """Checks for equality with the object’s `bondDid` field."""
  bondDid: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `token` field."""
  token: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `functionType` field."""
  functionType: String

  """Checks for equality with the object’s `functionParameters` field."""
  functionParameters: [JSON]

  """Checks for equality with the object’s `creatorDid` field."""
  creatorDid: String

  """Checks for equality with the object’s `controllerDid` field."""
  controllerDid: String

  """Checks for equality with the object’s `reserveTokens` field."""
  reserveTokens: [String]

  """Checks for equality with the object’s `txFeePercentage` field."""
  txFeePercentage: String

  """Checks for equality with the object’s `exitFeePercentage` field."""
  exitFeePercentage: String

  """Checks for equality with the object’s `feeAddress` field."""
  feeAddress: String

  """
  Checks for equality with the object’s `reserveWithdrawalAddress` field.
  """
  reserveWithdrawalAddress: String

  """Checks for equality with the object’s `maxSupply` field."""
  maxSupply: JSON

  """Checks for equality with the object’s `orderQuantityLimits` field."""
  orderQuantityLimits: [JSON]

  """Checks for equality with the object’s `sanityRate` field."""
  sanityRate: String

  """Checks for equality with the object’s `sanityMarginPercentage` field."""
  sanityMarginPercentage: String

  """Checks for equality with the object’s `currentSupply` field."""
  currentSupply: JSON

  """Checks for equality with the object’s `currentReserve` field."""
  currentReserve: [JSON]

  """Checks for equality with the object’s `availableReserve` field."""
  availableReserve: [JSON]

  """
  Checks for equality with the object’s `currentOutcomePaymentReserve` field.
  """
  currentOutcomePaymentReserve: [JSON]

  """Checks for equality with the object’s `allowSells` field."""
  allowSells: Boolean

  """Checks for equality with the object’s `allowReserveWithdrawals` field."""
  allowReserveWithdrawals: Boolean

  """Checks for equality with the object’s `alphaBond` field."""
  alphaBond: Boolean

  """Checks for equality with the object’s `batchBlocks` field."""
  batchBlocks: String

  """Checks for equality with the object’s `outcomePayment` field."""
  outcomePayment: String

  """Checks for equality with the object’s `oracleDid` field."""
  oracleDid: String
}

"""A connection to a list of `Chain` values."""
type ChainsConnection {
  """A list of `Chain` objects."""
  nodes: [Chain!]!

  """
  A list of edges which contains the `Chain` and cursor to aid in pagination.
  """
  edges: [ChainsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Chain` you could get from the connection."""
  totalCount: Int!
}

type Chain implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  chainId: String!
  blockHeight: Int!
}

"""A `Chain` edge in the connection."""
type ChainsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Chain` at the end of the edge."""
  node: Chain!
}

"""Methods to use when ordering `Chain`."""
enum ChainsOrderBy {
  NATURAL
  CHAIN_ID_ASC
  CHAIN_ID_DESC
  BLOCK_HEIGHT_ASC
  BLOCK_HEIGHT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Chain` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ChainCondition {
  """Checks for equality with the object’s `chainId` field."""
  chainId: String

  """Checks for equality with the object’s `blockHeight` field."""
  blockHeight: Int
}

"""
A filter to be used against `Chain` object types. All fields are combined with a logical ‘and.’
"""
input ChainFilter {
  """Filter by the object’s `chainId` field."""
  chainId: StringFilter

  """Filter by the object’s `blockHeight` field."""
  blockHeight: IntFilter

  """Checks for all expressions in this list."""
  and: [ChainFilter!]

  """Checks for any expressions in this list."""
  or: [ChainFilter!]

  """Negates the expression."""
  not: ChainFilter
}

"""A connection to a list of `Claim` values."""
type ClaimsConnection {
  """A list of `Claim` objects."""
  nodes: [Claim!]!

  """
  A list of edges which contains the `Claim` and cursor to aid in pagination.
  """
  edges: [ClaimsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Claim` you could get from the connection."""
  totalCount: Int!

  """# Checks if there are any claims with null schemaType"""
  claimSchemaTypesLoaded: Boolean!
}

type Claim implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  claimId: String!
  agentDid: String!
  agentAddress: String!
  submissionDate: Datetime!
  paymentsStatus: JSON!
  schemaType: String
  collectionId: String!

  """Reads a single `ClaimCollection` that is related to this `Claim`."""
  collection: ClaimCollection

  """Reads a single `Evaluation` that is related to this `Claim`."""
  evaluationByClaimId: Evaluation
}

type ClaimCollection implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  entity: String!
  admin: String!
  protocol: String!
  startDate: Datetime
  endDate: Datetime
  quota: Int!
  count: Int!
  evaluated: Int!
  approved: Int!
  rejected: Int!
  disputed: Int!
  state: Int!
  payments: JSON!

  """Reads and enables pagination through a set of `Claim`."""
  claimsByCollectionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Claim`."""
    orderBy: [ClaimsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClaimCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClaimFilter
  ): ClaimsConnection!
}

"""Methods to use when ordering `Claim`."""
enum ClaimsOrderBy {
  NATURAL
  CLAIM_ID_ASC
  CLAIM_ID_DESC
  AGENT_DID_ASC
  AGENT_DID_DESC
  AGENT_ADDRESS_ASC
  AGENT_ADDRESS_DESC
  SUBMISSION_DATE_ASC
  SUBMISSION_DATE_DESC
  PAYMENTS_STATUS_ASC
  PAYMENTS_STATUS_DESC
  SCHEMA_TYPE_ASC
  SCHEMA_TYPE_DESC
  COLLECTION_ID_ASC
  COLLECTION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Claim` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ClaimCondition {
  """Checks for equality with the object’s `claimId` field."""
  claimId: String

  """Checks for equality with the object’s `agentDid` field."""
  agentDid: String

  """Checks for equality with the object’s `agentAddress` field."""
  agentAddress: String

  """Checks for equality with the object’s `submissionDate` field."""
  submissionDate: Datetime

  """Checks for equality with the object’s `paymentsStatus` field."""
  paymentsStatus: JSON

  """Checks for equality with the object’s `schemaType` field."""
  schemaType: String

  """Checks for equality with the object’s `collectionId` field."""
  collectionId: String
}

"""
A filter to be used against `Claim` object types. All fields are combined with a logical ‘and.’
"""
input ClaimFilter {
  """Filter by the object’s `claimId` field."""
  claimId: StringFilter

  """Filter by the object’s `agentDid` field."""
  agentDid: StringFilter

  """Filter by the object’s `agentAddress` field."""
  agentAddress: StringFilter

  """Filter by the object’s `submissionDate` field."""
  submissionDate: DatetimeFilter

  """Filter by the object’s `paymentsStatus` field."""
  paymentsStatus: JSONFilter

  """Filter by the object’s `schemaType` field."""
  schemaType: StringFilter

  """Filter by the object’s `collectionId` field."""
  collectionId: StringFilter

  """Filter by the object’s `evaluationByClaimId` relation."""
  evaluationByClaimId: EvaluationFilter

  """A related `evaluationByClaimId` exists."""
  evaluationByClaimIdExists: Boolean

  """Filter by the object’s `collection` relation."""
  collection: ClaimCollectionFilter

  """Checks for all expressions in this list."""
  and: [ClaimFilter!]

  """Checks for any expressions in this list."""
  or: [ClaimFilter!]

  """Negates the expression."""
  not: ClaimFilter
}

"""
A filter to be used against `Evaluation` object types. All fields are combined with a logical ‘and.’
"""
input EvaluationFilter {
  """Filter by the object’s `collectionId` field."""
  collectionId: StringFilter

  """Filter by the object’s `oracle` field."""
  oracle: StringFilter

  """Filter by the object’s `agentDid` field."""
  agentDid: StringFilter

  """Filter by the object’s `agentAddress` field."""
  agentAddress: StringFilter

  """Filter by the object’s `status` field."""
  status: IntFilter

  """Filter by the object’s `reason` field."""
  reason: IntFilter

  """Filter by the object’s `verificationProof` field."""
  verificationProof: StringFilter

  """Filter by the object’s `amount` field."""
  amount: JSONFilter

  """Filter by the object’s `evaluationDate` field."""
  evaluationDate: DatetimeFilter

  """Filter by the object’s `claimId` field."""
  claimId: StringFilter

  """Filter by the object’s `claim` relation."""
  claim: ClaimFilter

  """Checks for all expressions in this list."""
  and: [EvaluationFilter!]

  """Checks for any expressions in this list."""
  or: [EvaluationFilter!]

  """Negates the expression."""
  not: EvaluationFilter
}

"""
A filter to be used against `ClaimCollection` object types. All fields are combined with a logical ‘and.’
"""
input ClaimCollectionFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `entity` field."""
  entity: StringFilter

  """Filter by the object’s `admin` field."""
  admin: StringFilter

  """Filter by the object’s `protocol` field."""
  protocol: StringFilter

  """Filter by the object’s `startDate` field."""
  startDate: DatetimeFilter

  """Filter by the object’s `endDate` field."""
  endDate: DatetimeFilter

  """Filter by the object’s `quota` field."""
  quota: IntFilter

  """Filter by the object’s `count` field."""
  count: IntFilter

  """Filter by the object’s `evaluated` field."""
  evaluated: IntFilter

  """Filter by the object’s `approved` field."""
  approved: IntFilter

  """Filter by the object’s `rejected` field."""
  rejected: IntFilter

  """Filter by the object’s `disputed` field."""
  disputed: IntFilter

  """Filter by the object’s `state` field."""
  state: IntFilter

  """Filter by the object’s `payments` field."""
  payments: JSONFilter

  """Filter by the object’s `claimsByCollectionId` relation."""
  claimsByCollectionId: ClaimCollectionToManyClaimFilter

  """Some related `claimsByCollectionId` exist."""
  claimsByCollectionIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [ClaimCollectionFilter!]

  """Checks for any expressions in this list."""
  or: [ClaimCollectionFilter!]

  """Negates the expression."""
  not: ClaimCollectionFilter
}

"""
A filter to be used against many `Claim` object types. All fields are combined with a logical ‘and.’
"""
input ClaimCollectionToManyClaimFilter {
  """
  Every related `Claim` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClaimFilter

  """
  Some related `Claim` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClaimFilter

  """
  No related `Claim` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClaimFilter
}

type Evaluation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  collectionId: String!
  oracle: String!
  agentDid: String!
  agentAddress: String!
  status: Int!
  reason: Int!
  verificationProof: String
  amount: JSON!
  evaluationDate: Datetime!
  claimId: String!

  """Reads a single `Claim` that is related to this `Evaluation`."""
  claim: Claim
}

"""A `Claim` edge in the connection."""
type ClaimsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Claim` at the end of the edge."""
  node: Claim!
}

"""A connection to a list of `ClaimCollection` values."""
type ClaimCollectionsConnection {
  """A list of `ClaimCollection` objects."""
  nodes: [ClaimCollection!]!

  """
  A list of edges which contains the `ClaimCollection` and cursor to aid in pagination.
  """
  edges: [ClaimCollectionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ClaimCollection` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ClaimCollection` edge in the connection."""
type ClaimCollectionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ClaimCollection` at the end of the edge."""
  node: ClaimCollection!
}

"""Methods to use when ordering `ClaimCollection`."""
enum ClaimCollectionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ENTITY_ASC
  ENTITY_DESC
  ADMIN_ASC
  ADMIN_DESC
  PROTOCOL_ASC
  PROTOCOL_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  QUOTA_ASC
  QUOTA_DESC
  COUNT_ASC
  COUNT_DESC
  EVALUATED_ASC
  EVALUATED_DESC
  APPROVED_ASC
  APPROVED_DESC
  REJECTED_ASC
  REJECTED_DESC
  DISPUTED_ASC
  DISPUTED_DESC
  STATE_ASC
  STATE_DESC
  PAYMENTS_ASC
  PAYMENTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ClaimCollection` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ClaimCollectionCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `entity` field."""
  entity: String

  """Checks for equality with the object’s `admin` field."""
  admin: String

  """Checks for equality with the object’s `protocol` field."""
  protocol: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: Datetime

  """Checks for equality with the object’s `endDate` field."""
  endDate: Datetime

  """Checks for equality with the object’s `quota` field."""
  quota: Int

  """Checks for equality with the object’s `count` field."""
  count: Int

  """Checks for equality with the object’s `evaluated` field."""
  evaluated: Int

  """Checks for equality with the object’s `approved` field."""
  approved: Int

  """Checks for equality with the object’s `rejected` field."""
  rejected: Int

  """Checks for equality with the object’s `disputed` field."""
  disputed: Int

  """Checks for equality with the object’s `state` field."""
  state: Int

  """Checks for equality with the object’s `payments` field."""
  payments: JSON
}

"""A connection to a list of `Dispute` values."""
type DisputesConnection {
  """A list of `Dispute` objects."""
  nodes: [Dispute!]!

  """
  A list of edges which contains the `Dispute` and cursor to aid in pagination.
  """
  edges: [DisputesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Dispute` you could get from the connection."""
  totalCount: Int!
}

type Dispute implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  proof: String!
  subjectId: String!
  type: Int!
  data: JSON!
}

"""A `Dispute` edge in the connection."""
type DisputesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Dispute` at the end of the edge."""
  node: Dispute!
}

"""Methods to use when ordering `Dispute`."""
enum DisputesOrderBy {
  NATURAL
  PROOF_ASC
  PROOF_DESC
  SUBJECT_ID_ASC
  SUBJECT_ID_DESC
  TYPE_ASC
  TYPE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Dispute` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input DisputeCondition {
  """Checks for equality with the object’s `proof` field."""
  proof: String

  """Checks for equality with the object’s `subjectId` field."""
  subjectId: String

  """Checks for equality with the object’s `type` field."""
  type: Int

  """Checks for equality with the object’s `data` field."""
  data: JSON
}

"""
A filter to be used against `Dispute` object types. All fields are combined with a logical ‘and.’
"""
input DisputeFilter {
  """Filter by the object’s `proof` field."""
  proof: StringFilter

  """Filter by the object’s `subjectId` field."""
  subjectId: StringFilter

  """Filter by the object’s `type` field."""
  type: IntFilter

  """Filter by the object’s `data` field."""
  data: JSONFilter

  """Checks for all expressions in this list."""
  and: [DisputeFilter!]

  """Checks for any expressions in this list."""
  or: [DisputeFilter!]

  """Negates the expression."""
  not: DisputeFilter
}

"""A connection to a list of `Entity` values."""
type EntitiesConnection {
  """A list of `Entity` objects."""
  nodes: [Entity!]!

  """
  A list of edges which contains the `Entity` and cursor to aid in pagination.
  """
  edges: [EntitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Entity` you could get from the connection."""
  totalCount: Int!

  """Checks if there are any asset/device entities with null externalId"""
  deviceExternalIdsLoaded: Boolean!
}

type Entity implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  type: String!
  startDate: Datetime
  endDate: Datetime
  status: Int!
  relayerNode: String!
  credentials: [String]
  entityVerified: Boolean!
  metadata: JSON!
  accounts: JSON!
  externalId: String
  owner: String

  """Reads a single `Iid` that is related to this `Entity`."""
  iidById: Iid

  """Reads and enables pagination through a set of `TokenClass`."""
  tokenClassesByClass(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenClass`."""
    orderBy: [TokenClassesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenClassCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenClassFilter
  ): TokenClassesConnection!

  """Reads and enables pagination through a set of `Token`."""
  tokensByCollection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Token`."""
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenFilter
  ): TokensConnection!
  context: JSON!
  controller: [String!]!
  verificationMethod: JSON!
  service: JSON!
  authentication: [String!]!
  assertionMethod: [String!]!
  keyAgreement: [String!]!
  capabilityInvocation: [String!]!
  capabilityDelegation: [String!]!
  linkedResource: JSON!
  linkedClaim: JSON!
  accordedRight: JSON!
  linkedEntity: JSON!
  alsoKnownAs: String!
  settings: JSON!
}

type Iid implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  context: JSON!
  controller: [String]
  verificationMethod: JSON!
  service: JSON!
  authentication: [String]
  assertionMethod: [String]
  keyAgreement: [String]
  capabilityInvocation: [String]
  capabilityDelegation: [String]
  linkedResource: JSON!
  linkedClaim: JSON!
  accordedRight: JSON!
  linkedEntity: JSON!
  alsoKnownAs: String!
  metadata: JSON!

  """Reads a single `Entity` that is related to this `Iid`."""
  entityById: Entity
}

"""A connection to a list of `TokenClass` values."""
type TokenClassesConnection {
  """A list of `TokenClass` objects."""
  nodes: [TokenClass!]!

  """
  A list of edges which contains the `TokenClass` and cursor to aid in pagination.
  """
  edges: [TokenClassesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TokenClass` you could get from the connection."""
  totalCount: Int!
}

type TokenClass implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  contractAddress: String!
  minter: String!
  class: String!
  name: String!
  description: String!
  image: String!
  type: String!
  cap: String!
  supply: String!
  paused: Boolean!
  stopped: Boolean!

  """Reads a single `Entity` that is related to this `TokenClass`."""
  entityByClass: Entity

  """Reads and enables pagination through a set of `Token`."""
  tokensByName(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Token`."""
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenFilter
  ): TokensConnection!

  """Reads and enables pagination through a set of `TokenRetired`."""
  tokenRetiredsByName(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenRetired`."""
    orderBy: [TokenRetiredsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenRetiredCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenRetiredFilter
  ): TokenRetiredsConnection!

  """Reads and enables pagination through a set of `TokenCancelled`."""
  tokenCancelledsByName(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenCancelled`."""
    orderBy: [TokenCancelledsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenCancelledCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenCancelledFilter
  ): TokenCancelledsConnection!
}

"""A connection to a list of `Token` values."""
type TokensConnection {
  """A list of `Token` objects."""
  nodes: [Token!]!

  """
  A list of edges which contains the `Token` and cursor to aid in pagination.
  """
  edges: [TokensEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Token` you could get from the connection."""
  totalCount: Int!
}

type Token implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  index: String!
  name: String!
  collection: String!

  """Reads a single `TokenClass` that is related to this `Token`."""
  tokenClassByName: TokenClass

  """Reads a single `Entity` that is related to this `Token`."""
  entityByCollection: Entity

  """Reads and enables pagination through a set of `TokenDatum`."""
  tokenDataByTokenId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenDatum`."""
    orderBy: [TokenDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenDatumFilter
  ): TokenDataConnection!

  """Reads and enables pagination through a set of `TokenTransaction`."""
  tokenTransactionsByTokenId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TokenTransaction`."""
    orderBy: [TokenTransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TokenTransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TokenTransactionFilter
  ): TokenTransactionsConnection!
}

"""A connection to a list of `TokenDatum` values."""
type TokenDataConnection {
  """A list of `TokenDatum` objects."""
  nodes: [TokenDatum!]!

  """
  A list of edges which contains the `TokenDatum` and cursor to aid in pagination.
  """
  edges: [TokenDataEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TokenDatum` you could get from the connection."""
  totalCount: Int!
}

type TokenDatum implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  aid: Int!
  uri: String!
  encrypted: Boolean!
  proof: String!
  type: String!
  id: String!
  tokenId: String!

  """Reads a single `Token` that is related to this `TokenDatum`."""
  token: Token
}

"""A `TokenDatum` edge in the connection."""
type TokenDataEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TokenDatum` at the end of the edge."""
  node: TokenDatum!
}

"""Methods to use when ordering `TokenDatum`."""
enum TokenDataOrderBy {
  NATURAL
  AID_ASC
  AID_DESC
  URI_ASC
  URI_DESC
  ENCRYPTED_ASC
  ENCRYPTED_DESC
  PROOF_ASC
  PROOF_DESC
  TYPE_ASC
  TYPE_DESC
  ID_ASC
  ID_DESC
  TOKEN_ID_ASC
  TOKEN_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TokenDatum` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TokenDatumCondition {
  """Checks for equality with the object’s `aid` field."""
  aid: Int

  """Checks for equality with the object’s `uri` field."""
  uri: String

  """Checks for equality with the object’s `encrypted` field."""
  encrypted: Boolean

  """Checks for equality with the object’s `proof` field."""
  proof: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `tokenId` field."""
  tokenId: String
}

"""
A filter to be used against `TokenDatum` object types. All fields are combined with a logical ‘and.’
"""
input TokenDatumFilter {
  """Filter by the object’s `aid` field."""
  aid: IntFilter

  """Filter by the object’s `uri` field."""
  uri: StringFilter

  """Filter by the object’s `encrypted` field."""
  encrypted: BooleanFilter

  """Filter by the object’s `proof` field."""
  proof: StringFilter

  """Filter by the object’s `type` field."""
  type: StringFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `tokenId` field."""
  tokenId: StringFilter

  """Filter by the object’s `token` relation."""
  token: TokenFilter

  """Checks for all expressions in this list."""
  and: [TokenDatumFilter!]

  """Checks for any expressions in this list."""
  or: [TokenDatumFilter!]

  """Negates the expression."""
  not: TokenDatumFilter
}

"""
A filter to be used against `Token` object types. All fields are combined with a logical ‘and.’
"""
input TokenFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `index` field."""
  index: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `collection` field."""
  collection: StringFilter

  """Filter by the object’s `tokenDataByTokenId` relation."""
  tokenDataByTokenId: TokenToManyTokenDatumFilter

  """Some related `tokenDataByTokenId` exist."""
  tokenDataByTokenIdExist: Boolean

  """Filter by the object’s `tokenTransactionsByTokenId` relation."""
  tokenTransactionsByTokenId: TokenToManyTokenTransactionFilter

  """Some related `tokenTransactionsByTokenId` exist."""
  tokenTransactionsByTokenIdExist: Boolean

  """Filter by the object’s `tokenClassByName` relation."""
  tokenClassByName: TokenClassFilter

  """Filter by the object’s `entityByCollection` relation."""
  entityByCollection: EntityFilter

  """Checks for all expressions in this list."""
  and: [TokenFilter!]

  """Checks for any expressions in this list."""
  or: [TokenFilter!]

  """Negates the expression."""
  not: TokenFilter
}

"""
A filter to be used against many `TokenDatum` object types. All fields are combined with a logical ‘and.’
"""
input TokenToManyTokenDatumFilter {
  """
  Every related `TokenDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenDatumFilter

  """
  Some related `TokenDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenDatumFilter

  """
  No related `TokenDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenDatumFilter
}

"""
A filter to be used against many `TokenTransaction` object types. All fields are combined with a logical ‘and.’
"""
input TokenToManyTokenTransactionFilter {
  """
  Every related `TokenTransaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenTransactionFilter

  """
  Some related `TokenTransaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenTransactionFilter

  """
  No related `TokenTransaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenTransactionFilter
}

"""
A filter to be used against `TokenTransaction` object types. All fields are combined with a logical ‘and.’
"""
input TokenTransactionFilter {
  """Filter by the object’s `aid` field."""
  aid: IntFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Filter by the object’s `to` field."""
  to: StringFilter

  """Filter by the object’s `amount` field."""
  amount: StringFilter

  """Filter by the object’s `tokenId` field."""
  tokenId: StringFilter

  """Filter by the object’s `token` relation."""
  token: TokenFilter

  """Checks for all expressions in this list."""
  and: [TokenTransactionFilter!]

  """Checks for any expressions in this list."""
  or: [TokenTransactionFilter!]

  """Negates the expression."""
  not: TokenTransactionFilter
}

"""
A filter to be used against `TokenClass` object types. All fields are combined with a logical ‘and.’
"""
input TokenClassFilter {
  """Filter by the object’s `contractAddress` field."""
  contractAddress: StringFilter

  """Filter by the object’s `minter` field."""
  minter: StringFilter

  """Filter by the object’s `class` field."""
  class: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `image` field."""
  image: StringFilter

  """Filter by the object’s `type` field."""
  type: StringFilter

  """Filter by the object’s `cap` field."""
  cap: StringFilter

  """Filter by the object’s `supply` field."""
  supply: StringFilter

  """Filter by the object’s `paused` field."""
  paused: BooleanFilter

  """Filter by the object’s `stopped` field."""
  stopped: BooleanFilter

  """Filter by the object’s `tokensByName` relation."""
  tokensByName: TokenClassToManyTokenFilter

  """Some related `tokensByName` exist."""
  tokensByNameExist: Boolean

  """Filter by the object’s `tokenRetiredsByName` relation."""
  tokenRetiredsByName: TokenClassToManyTokenRetiredFilter

  """Some related `tokenRetiredsByName` exist."""
  tokenRetiredsByNameExist: Boolean

  """Filter by the object’s `tokenCancelledsByName` relation."""
  tokenCancelledsByName: TokenClassToManyTokenCancelledFilter

  """Some related `tokenCancelledsByName` exist."""
  tokenCancelledsByNameExist: Boolean

  """Filter by the object’s `entityByClass` relation."""
  entityByClass: EntityFilter

  """Checks for all expressions in this list."""
  and: [TokenClassFilter!]

  """Checks for any expressions in this list."""
  or: [TokenClassFilter!]

  """Negates the expression."""
  not: TokenClassFilter
}

"""
A filter to be used against many `Token` object types. All fields are combined with a logical ‘and.’
"""
input TokenClassToManyTokenFilter {
  """
  Every related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenFilter

  """
  Some related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenFilter

  """
  No related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenFilter
}

"""
A filter to be used against many `TokenRetired` object types. All fields are combined with a logical ‘and.’
"""
input TokenClassToManyTokenRetiredFilter {
  """
  Every related `TokenRetired` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenRetiredFilter

  """
  Some related `TokenRetired` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenRetiredFilter

  """
  No related `TokenRetired` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenRetiredFilter
}

"""
A filter to be used against `TokenRetired` object types. All fields are combined with a logical ‘and.’
"""
input TokenRetiredFilter {
  """Filter by the object’s `aid` field."""
  aid: IntFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `reason` field."""
  reason: StringFilter

  """Filter by the object’s `jurisdiction` field."""
  jurisdiction: StringFilter

  """Filter by the object’s `amount` field."""
  amount: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `tokenClassByName` relation."""
  tokenClassByName: TokenClassFilter

  """Checks for all expressions in this list."""
  and: [TokenRetiredFilter!]

  """Checks for any expressions in this list."""
  or: [TokenRetiredFilter!]

  """Negates the expression."""
  not: TokenRetiredFilter
}

"""
A filter to be used against many `TokenCancelled` object types. All fields are combined with a logical ‘and.’
"""
input TokenClassToManyTokenCancelledFilter {
  """
  Every related `TokenCancelled` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenCancelledFilter

  """
  Some related `TokenCancelled` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenCancelledFilter

  """
  No related `TokenCancelled` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenCancelledFilter
}

"""
A filter to be used against `TokenCancelled` object types. All fields are combined with a logical ‘and.’
"""
input TokenCancelledFilter {
  """Filter by the object’s `aid` field."""
  aid: IntFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `reason` field."""
  reason: StringFilter

  """Filter by the object’s `amount` field."""
  amount: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `tokenClassByName` relation."""
  tokenClassByName: TokenClassFilter

  """Checks for all expressions in this list."""
  and: [TokenCancelledFilter!]

  """Checks for any expressions in this list."""
  or: [TokenCancelledFilter!]

  """Negates the expression."""
  not: TokenCancelledFilter
}

"""
A filter to be used against `Entity` object types. All fields are combined with a logical ‘and.’
"""
input EntityFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `type` field."""
  type: StringFilter

  """Filter by the object’s `startDate` field."""
  startDate: DatetimeFilter

  """Filter by the object’s `endDate` field."""
  endDate: DatetimeFilter

  """Filter by the object’s `status` field."""
  status: IntFilter

  """Filter by the object’s `relayerNode` field."""
  relayerNode: StringFilter

  """Filter by the object’s `credentials` field."""
  credentials: StringListFilter

  """Filter by the object’s `entityVerified` field."""
  entityVerified: BooleanFilter

  """Filter by the object’s `metadata` field."""
  metadata: JSONFilter

  """Filter by the object’s `accounts` field."""
  accounts: JSONFilter

  """Filter by the object’s `externalId` field."""
  externalId: StringFilter

  """Filter by the object’s `owner` field."""
  owner: StringFilter

  """Filter by the object’s `tokenClassesByClass` relation."""
  tokenClassesByClass: EntityToManyTokenClassFilter

  """Some related `tokenClassesByClass` exist."""
  tokenClassesByClassExist: Boolean

  """Filter by the object’s `tokensByCollection` relation."""
  tokensByCollection: EntityToManyTokenFilter

  """Some related `tokensByCollection` exist."""
  tokensByCollectionExist: Boolean

  """Filter by the object’s `iidById` relation."""
  iidById: IidFilter

  """Checks for all expressions in this list."""
  and: [EntityFilter!]

  """Checks for any expressions in this list."""
  or: [EntityFilter!]

  """Negates the expression."""
  not: EntityFilter
}

"""
A filter to be used against many `TokenClass` object types. All fields are combined with a logical ‘and.’
"""
input EntityToManyTokenClassFilter {
  """
  Every related `TokenClass` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenClassFilter

  """
  Some related `TokenClass` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenClassFilter

  """
  No related `TokenClass` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenClassFilter
}

"""
A filter to be used against many `Token` object types. All fields are combined with a logical ‘and.’
"""
input EntityToManyTokenFilter {
  """
  Every related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TokenFilter

  """
  Some related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TokenFilter

  """
  No related `Token` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TokenFilter
}

"""
A filter to be used against `Iid` object types. All fields are combined with a logical ‘and.’
"""
input IidFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `context` field."""
  context: JSONFilter

  """Filter by the object’s `controller` field."""
  controller: StringListFilter

  """Filter by the object’s `verificationMethod` field."""
  verificationMethod: JSONFilter

  """Filter by the object’s `service` field."""
  service: JSONFilter

  """Filter by the object’s `authentication` field."""
  authentication: StringListFilter

  """Filter by the object’s `assertionMethod` field."""
  assertionMethod: StringListFilter

  """Filter by the object’s `keyAgreement` field."""
  keyAgreement: StringListFilter

  """Filter by the object’s `capabilityInvocation` field."""
  capabilityInvocation: StringListFilter

  """Filter by the object’s `capabilityDelegation` field."""
  capabilityDelegation: StringListFilter

  """Filter by the object’s `linkedResource` field."""
  linkedResource: JSONFilter

  """Filter by the object’s `linkedClaim` field."""
  linkedClaim: JSONFilter

  """Filter by the object’s `accordedRight` field."""
  accordedRight: JSONFilter

  """Filter by the object’s `linkedEntity` field."""
  linkedEntity: JSONFilter

  """Filter by the object’s `alsoKnownAs` field."""
  alsoKnownAs: StringFilter

  """Filter by the object’s `metadata` field."""
  metadata: JSONFilter

  """Filter by the object’s `entityById` relation."""
  entityById: EntityFilter

  """A related `entityById` exists."""
  entityByIdExists: Boolean

  """Checks for all expressions in this list."""
  and: [IidFilter!]

  """Checks for any expressions in this list."""
  or: [IidFilter!]

  """Negates the expression."""
  not: IidFilter
}

"""A connection to a list of `TokenTransaction` values."""
type TokenTransactionsConnection {
  """A list of `TokenTransaction` objects."""
  nodes: [TokenTransaction!]!

  """
  A list of edges which contains the `TokenTransaction` and cursor to aid in pagination.
  """
  edges: [TokenTransactionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `TokenTransaction` you could get from the connection.
  """
  totalCount: Int!
}

type TokenTransaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  aid: Int!
  from: String!
  to: String!
  amount: String!
  tokenId: String!

  """Reads a single `Token` that is related to this `TokenTransaction`."""
  token: Token
}

"""A `TokenTransaction` edge in the connection."""
type TokenTransactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TokenTransaction` at the end of the edge."""
  node: TokenTransaction!
}

"""Methods to use when ordering `TokenTransaction`."""
enum TokenTransactionsOrderBy {
  NATURAL
  AID_ASC
  AID_DESC
  FROM_ASC
  FROM_DESC
  TO_ASC
  TO_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  TOKEN_ID_ASC
  TOKEN_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TokenTransaction` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TokenTransactionCondition {
  """Checks for equality with the object’s `aid` field."""
  aid: Int

  """Checks for equality with the object’s `from` field."""
  from: String

  """Checks for equality with the object’s `to` field."""
  to: String

  """Checks for equality with the object’s `amount` field."""
  amount: String

  """Checks for equality with the object’s `tokenId` field."""
  tokenId: String
}

"""A `Token` edge in the connection."""
type TokensEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Token` at the end of the edge."""
  node: Token!
}

"""Methods to use when ordering `Token`."""
enum TokensOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  INDEX_ASC
  INDEX_DESC
  NAME_ASC
  NAME_DESC
  COLLECTION_ASC
  COLLECTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Token` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TokenCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `index` field."""
  index: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `collection` field."""
  collection: String
}

"""A connection to a list of `TokenRetired` values."""
type TokenRetiredsConnection {
  """A list of `TokenRetired` objects."""
  nodes: [TokenRetired!]!

  """
  A list of edges which contains the `TokenRetired` and cursor to aid in pagination.
  """
  edges: [TokenRetiredsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TokenRetired` you could get from the connection."""
  totalCount: Int!
}

type TokenRetired implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  aid: Int!
  id: String!
  reason: String!
  jurisdiction: String!
  amount: String!
  owner: String!
  name: String!

  """Reads a single `TokenClass` that is related to this `TokenRetired`."""
  tokenClassByName: TokenClass
}

"""A `TokenRetired` edge in the connection."""
type TokenRetiredsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TokenRetired` at the end of the edge."""
  node: TokenRetired!
}

"""Methods to use when ordering `TokenRetired`."""
enum TokenRetiredsOrderBy {
  NATURAL
  AID_ASC
  AID_DESC
  ID_ASC
  ID_DESC
  REASON_ASC
  REASON_DESC
  JURISDICTION_ASC
  JURISDICTION_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  OWNER_ASC
  OWNER_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TokenRetired` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TokenRetiredCondition {
  """Checks for equality with the object’s `aid` field."""
  aid: Int

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `reason` field."""
  reason: String

  """Checks for equality with the object’s `jurisdiction` field."""
  jurisdiction: String

  """Checks for equality with the object’s `amount` field."""
  amount: String

  """Checks for equality with the object’s `owner` field."""
  owner: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `TokenCancelled` values."""
type TokenCancelledsConnection {
  """A list of `TokenCancelled` objects."""
  nodes: [TokenCancelled!]!

  """
  A list of edges which contains the `TokenCancelled` and cursor to aid in pagination.
  """
  edges: [TokenCancelledsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TokenCancelled` you could get from the connection."""
  totalCount: Int!
}

type TokenCancelled implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  aid: Int!
  id: String!
  reason: String!
  amount: String!
  owner: String!
  name: String!

  """Reads a single `TokenClass` that is related to this `TokenCancelled`."""
  tokenClassByName: TokenClass
}

"""A `TokenCancelled` edge in the connection."""
type TokenCancelledsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TokenCancelled` at the end of the edge."""
  node: TokenCancelled!
}

"""Methods to use when ordering `TokenCancelled`."""
enum TokenCancelledsOrderBy {
  NATURAL
  AID_ASC
  AID_DESC
  ID_ASC
  ID_DESC
  REASON_ASC
  REASON_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  OWNER_ASC
  OWNER_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TokenCancelled` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TokenCancelledCondition {
  """Checks for equality with the object’s `aid` field."""
  aid: Int

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `reason` field."""
  reason: String

  """Checks for equality with the object’s `amount` field."""
  amount: String

  """Checks for equality with the object’s `owner` field."""
  owner: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A `TokenClass` edge in the connection."""
type TokenClassesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TokenClass` at the end of the edge."""
  node: TokenClass!
}

"""Methods to use when ordering `TokenClass`."""
enum TokenClassesOrderBy {
  NATURAL
  CONTRACT_ADDRESS_ASC
  CONTRACT_ADDRESS_DESC
  MINTER_ASC
  MINTER_DESC
  CLASS_ASC
  CLASS_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  TYPE_ASC
  TYPE_DESC
  CAP_ASC
  CAP_DESC
  SUPPLY_ASC
  SUPPLY_DESC
  PAUSED_ASC
  PAUSED_DESC
  STOPPED_ASC
  STOPPED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TokenClass` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TokenClassCondition {
  """Checks for equality with the object’s `contractAddress` field."""
  contractAddress: String

  """Checks for equality with the object’s `minter` field."""
  minter: String

  """Checks for equality with the object’s `class` field."""
  class: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `cap` field."""
  cap: String

  """Checks for equality with the object’s `supply` field."""
  supply: String

  """Checks for equality with the object’s `paused` field."""
  paused: Boolean

  """Checks for equality with the object’s `stopped` field."""
  stopped: Boolean
}

"""A `Entity` edge in the connection."""
type EntitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Entity` at the end of the edge."""
  node: Entity!
}

"""Methods to use when ordering `Entity`."""
enum EntitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  RELAYER_NODE_ASC
  RELAYER_NODE_DESC
  CREDENTIALS_ASC
  CREDENTIALS_DESC
  ENTITY_VERIFIED_ASC
  ENTITY_VERIFIED_DESC
  METADATA_ASC
  METADATA_DESC
  ACCOUNTS_ASC
  ACCOUNTS_DESC
  EXTERNAL_ID_ASC
  EXTERNAL_ID_DESC
  OWNER_ASC
  OWNER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Entity` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EntityCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: Datetime

  """Checks for equality with the object’s `endDate` field."""
  endDate: Datetime

  """Checks for equality with the object’s `status` field."""
  status: Int

  """Checks for equality with the object’s `relayerNode` field."""
  relayerNode: String

  """Checks for equality with the object’s `credentials` field."""
  credentials: [String]

  """Checks for equality with the object’s `entityVerified` field."""
  entityVerified: Boolean

  """Checks for equality with the object’s `metadata` field."""
  metadata: JSON

  """Checks for equality with the object’s `accounts` field."""
  accounts: JSON

  """Checks for equality with the object’s `externalId` field."""
  externalId: String

  """Checks for equality with the object’s `owner` field."""
  owner: String
}

"""A connection to a list of `Evaluation` values."""
type EvaluationsConnection {
  """A list of `Evaluation` objects."""
  nodes: [Evaluation!]!

  """
  A list of edges which contains the `Evaluation` and cursor to aid in pagination.
  """
  edges: [EvaluationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Evaluation` you could get from the connection."""
  totalCount: Int!
}

"""A `Evaluation` edge in the connection."""
type EvaluationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Evaluation` at the end of the edge."""
  node: Evaluation!
}

"""Methods to use when ordering `Evaluation`."""
enum EvaluationsOrderBy {
  NATURAL
  COLLECTION_ID_ASC
  COLLECTION_ID_DESC
  ORACLE_ASC
  ORACLE_DESC
  AGENT_DID_ASC
  AGENT_DID_DESC
  AGENT_ADDRESS_ASC
  AGENT_ADDRESS_DESC
  STATUS_ASC
  STATUS_DESC
  REASON_ASC
  REASON_DESC
  VERIFICATION_PROOF_ASC
  VERIFICATION_PROOF_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  EVALUATION_DATE_ASC
  EVALUATION_DATE_DESC
  CLAIM_ID_ASC
  CLAIM_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Evaluation` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EvaluationCondition {
  """Checks for equality with the object’s `collectionId` field."""
  collectionId: String

  """Checks for equality with the object’s `oracle` field."""
  oracle: String

  """Checks for equality with the object’s `agentDid` field."""
  agentDid: String

  """Checks for equality with the object’s `agentAddress` field."""
  agentAddress: String

  """Checks for equality with the object’s `status` field."""
  status: Int

  """Checks for equality with the object’s `reason` field."""
  reason: Int

  """Checks for equality with the object’s `verificationProof` field."""
  verificationProof: String

  """Checks for equality with the object’s `amount` field."""
  amount: JSON

  """Checks for equality with the object’s `evaluationDate` field."""
  evaluationDate: Datetime

  """Checks for equality with the object’s `claimId` field."""
  claimId: String
}

"""A connection to a list of `Iid` values."""
type IidsConnection {
  """A list of `Iid` objects."""
  nodes: [Iid!]!

  """
  A list of edges which contains the `Iid` and cursor to aid in pagination.
  """
  edges: [IidsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Iid` you could get from the connection."""
  totalCount: Int!
}

"""A `Iid` edge in the connection."""
type IidsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Iid` at the end of the edge."""
  node: Iid!
}

"""Methods to use when ordering `Iid`."""
enum IidsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CONTEXT_ASC
  CONTEXT_DESC
  CONTROLLER_ASC
  CONTROLLER_DESC
  VERIFICATION_METHOD_ASC
  VERIFICATION_METHOD_DESC
  SERVICE_ASC
  SERVICE_DESC
  AUTHENTICATION_ASC
  AUTHENTICATION_DESC
  ASSERTION_METHOD_ASC
  ASSERTION_METHOD_DESC
  KEY_AGREEMENT_ASC
  KEY_AGREEMENT_DESC
  CAPABILITY_INVOCATION_ASC
  CAPABILITY_INVOCATION_DESC
  CAPABILITY_DELEGATION_ASC
  CAPABILITY_DELEGATION_DESC
  LINKED_RESOURCE_ASC
  LINKED_RESOURCE_DESC
  LINKED_CLAIM_ASC
  LINKED_CLAIM_DESC
  ACCORDED_RIGHT_ASC
  ACCORDED_RIGHT_DESC
  LINKED_ENTITY_ASC
  LINKED_ENTITY_DESC
  ALSO_KNOWN_AS_ASC
  ALSO_KNOWN_AS_DESC
  METADATA_ASC
  METADATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Iid` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input IidCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `context` field."""
  context: JSON

  """Checks for equality with the object’s `controller` field."""
  controller: [String]

  """Checks for equality with the object’s `verificationMethod` field."""
  verificationMethod: JSON

  """Checks for equality with the object’s `service` field."""
  service: JSON

  """Checks for equality with the object’s `authentication` field."""
  authentication: [String]

  """Checks for equality with the object’s `assertionMethod` field."""
  assertionMethod: [String]

  """Checks for equality with the object’s `keyAgreement` field."""
  keyAgreement: [String]

  """Checks for equality with the object’s `capabilityInvocation` field."""
  capabilityInvocation: [String]

  """Checks for equality with the object’s `capabilityDelegation` field."""
  capabilityDelegation: [String]

  """Checks for equality with the object’s `linkedResource` field."""
  linkedResource: JSON

  """Checks for equality with the object’s `linkedClaim` field."""
  linkedClaim: JSON

  """Checks for equality with the object’s `accordedRight` field."""
  accordedRight: JSON

  """Checks for equality with the object’s `linkedEntity` field."""
  linkedEntity: JSON

  """Checks for equality with the object’s `alsoKnownAs` field."""
  alsoKnownAs: String

  """Checks for equality with the object’s `metadata` field."""
  metadata: JSON
}

"""A connection to a list of `Ipf` values."""
type IpfsConnection {
  """A list of `Ipf` objects."""
  nodes: [Ipf!]!

  """
  A list of edges which contains the `Ipf` and cursor to aid in pagination.
  """
  edges: [IpfsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ipf` you could get from the connection."""
  totalCount: Int!
}

type Ipf implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  cid: String!
  contentType: String!
  data: String!
}

"""A `Ipf` edge in the connection."""
type IpfsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ipf` at the end of the edge."""
  node: Ipf!
}

"""Methods to use when ordering `Ipf`."""
enum IpfsOrderBy {
  NATURAL
  CID_ASC
  CID_DESC
  CONTENT_TYPE_ASC
  CONTENT_TYPE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ipf` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input IpfCondition {
  """Checks for equality with the object’s `cid` field."""
  cid: String

  """Checks for equality with the object’s `contentType` field."""
  contentType: String

  """Checks for equality with the object’s `data` field."""
  data: String
}

"""
A filter to be used against `Ipf` object types. All fields are combined with a logical ‘and.’
"""
input IpfFilter {
  """Filter by the object’s `cid` field."""
  cid: StringFilter

  """Filter by the object’s `contentType` field."""
  contentType: StringFilter

  """Filter by the object’s `data` field."""
  data: StringFilter

  """Checks for all expressions in this list."""
  and: [IpfFilter!]

  """Checks for any expressions in this list."""
  or: [IpfFilter!]

  """Negates the expression."""
  not: IpfFilter
}

"""A connection to a list of `Message` values."""
type MessagesConnection {
  """A list of `Message` objects."""
  nodes: [Message!]!

  """
  A list of edges which contains the `Message` and cursor to aid in pagination.
  """
  edges: [MessagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Message` you could get from the connection."""
  totalCount: Int!
}

type Message implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  typeUrl: String!
  value: JSON!
  from: String
  to: String
  denoms: [String]
  tokenNames: [String]
  transactionHash: String!

  """Reads a single `Transaction` that is related to this `Message`."""
  transactionByTransactionHash: Transaction
}

type Transaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  hash: String!
  height: Int!
  code: Int!
  fee: JSON!
  gasUsed: String!
  gasWanted: String!
  time: Datetime!

  """Reads and enables pagination through a set of `Message`."""
  messagesByTransactionHash(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MessageFilter
  ): MessagesConnection!
}

"""Methods to use when ordering `Message`."""
enum MessagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_URL_ASC
  TYPE_URL_DESC
  VALUE_ASC
  VALUE_DESC
  FROM_ASC
  FROM_DESC
  TO_ASC
  TO_DESC
  DENOMS_ASC
  DENOMS_DESC
  TOKEN_NAMES_ASC
  TOKEN_NAMES_DESC
  TRANSACTION_HASH_ASC
  TRANSACTION_HASH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MessageCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `typeUrl` field."""
  typeUrl: String

  """Checks for equality with the object’s `value` field."""
  value: JSON

  """Checks for equality with the object’s `from` field."""
  from: String

  """Checks for equality with the object’s `to` field."""
  to: String

  """Checks for equality with the object’s `denoms` field."""
  denoms: [String]

  """Checks for equality with the object’s `tokenNames` field."""
  tokenNames: [String]

  """Checks for equality with the object’s `transactionHash` field."""
  transactionHash: String
}

"""
A filter to be used against `Message` object types. All fields are combined with a logical ‘and.’
"""
input MessageFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `typeUrl` field."""
  typeUrl: StringFilter

  """Filter by the object’s `value` field."""
  value: JSONFilter

  """Filter by the object’s `from` field."""
  from: StringFilter

  """Filter by the object’s `to` field."""
  to: StringFilter

  """Filter by the object’s `denoms` field."""
  denoms: StringListFilter

  """Filter by the object’s `tokenNames` field."""
  tokenNames: StringListFilter

  """Filter by the object’s `transactionHash` field."""
  transactionHash: StringFilter

  """Filter by the object’s `transactionByTransactionHash` relation."""
  transactionByTransactionHash: TransactionFilter

  """Checks for all expressions in this list."""
  and: [MessageFilter!]

  """Checks for any expressions in this list."""
  or: [MessageFilter!]

  """Negates the expression."""
  not: MessageFilter
}

"""
A filter to be used against `Transaction` object types. All fields are combined with a logical ‘and.’
"""
input TransactionFilter {
  """Filter by the object’s `hash` field."""
  hash: StringFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `code` field."""
  code: IntFilter

  """Filter by the object’s `fee` field."""
  fee: JSONFilter

  """Filter by the object’s `gasUsed` field."""
  gasUsed: StringFilter

  """Filter by the object’s `gasWanted` field."""
  gasWanted: StringFilter

  """Filter by the object’s `time` field."""
  time: DatetimeFilter

  """Filter by the object’s `messagesByTransactionHash` relation."""
  messagesByTransactionHash: TransactionToManyMessageFilter

  """Some related `messagesByTransactionHash` exist."""
  messagesByTransactionHashExist: Boolean

  """Checks for all expressions in this list."""
  and: [TransactionFilter!]

  """Checks for any expressions in this list."""
  or: [TransactionFilter!]

  """Negates the expression."""
  not: TransactionFilter
}

"""
A filter to be used against many `Message` object types. All fields are combined with a logical ‘and.’
"""
input TransactionToManyMessageFilter {
  """
  Every related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MessageFilter

  """
  Some related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MessageFilter

  """
  No related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MessageFilter
}

"""A `Message` edge in the connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Message` at the end of the edge."""
  node: Message!
}

"""A connection to a list of `Transaction` values."""
type TransactionsConnection {
  """A list of `Transaction` objects."""
  nodes: [Transaction!]!

  """
  A list of edges which contains the `Transaction` and cursor to aid in pagination.
  """
  edges: [TransactionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Transaction` you could get from the connection."""
  totalCount: Int!
}

"""A `Transaction` edge in the connection."""
type TransactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Transaction` at the end of the edge."""
  node: Transaction!
}

"""Methods to use when ordering `Transaction`."""
enum TransactionsOrderBy {
  NATURAL
  HASH_ASC
  HASH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  CODE_ASC
  CODE_DESC
  FEE_ASC
  FEE_DESC
  GAS_USED_ASC
  GAS_USED_DESC
  GAS_WANTED_ASC
  GAS_WANTED_DESC
  TIME_ASC
  TIME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Transaction` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TransactionCondition {
  """Checks for equality with the object’s `hash` field."""
  hash: String

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `code` field."""
  code: Int

  """Checks for equality with the object’s `fee` field."""
  fee: JSON

  """Checks for equality with the object’s `gasUsed` field."""
  gasUsed: String

  """Checks for equality with the object’s `gasWanted` field."""
  gasWanted: String

  """Checks for equality with the object’s `time` field."""
  time: Datetime
}

"""A connection to a list of `_PrismaMigration` values."""
type _PrismaMigrationsConnection {
  """A list of `_PrismaMigration` objects."""
  nodes: [_PrismaMigration!]!

  """
  A list of edges which contains the `_PrismaMigration` and cursor to aid in pagination.
  """
  edges: [_PrismaMigrationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `_PrismaMigration` you could get from the connection.
  """
  totalCount: Int!
}

type _PrismaMigration implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  checksum: String!
  finishedAt: Datetime
  migrationName: String!
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime!
  appliedStepsCount: Int!
}

"""A `_PrismaMigration` edge in the connection."""
type _PrismaMigrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `_PrismaMigration` at the end of the edge."""
  node: _PrismaMigration!
}

"""Methods to use when ordering `_PrismaMigration`."""
enum _PrismaMigrationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CHECKSUM_ASC
  CHECKSUM_DESC
  FINISHED_AT_ASC
  FINISHED_AT_DESC
  MIGRATION_NAME_ASC
  MIGRATION_NAME_DESC
  LOGS_ASC
  LOGS_DESC
  ROLLED_BACK_AT_ASC
  ROLLED_BACK_AT_DESC
  STARTED_AT_ASC
  STARTED_AT_DESC
  APPLIED_STEPS_COUNT_ASC
  APPLIED_STEPS_COUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `_PrismaMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input _PrismaMigrationCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `checksum` field."""
  checksum: String

  """Checks for equality with the object’s `finishedAt` field."""
  finishedAt: Datetime

  """Checks for equality with the object’s `migrationName` field."""
  migrationName: String

  """Checks for equality with the object’s `logs` field."""
  logs: String

  """Checks for equality with the object’s `rolledBackAt` field."""
  rolledBackAt: Datetime

  """Checks for equality with the object’s `startedAt` field."""
  startedAt: Datetime

  """Checks for equality with the object’s `appliedStepsCount` field."""
  appliedStepsCount: Int
}

"""
A filter to be used against `_PrismaMigration` object types. All fields are combined with a logical ‘and.’
"""
input _PrismaMigrationFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `checksum` field."""
  checksum: StringFilter

  """Filter by the object’s `finishedAt` field."""
  finishedAt: DatetimeFilter

  """Filter by the object’s `migrationName` field."""
  migrationName: StringFilter

  """Filter by the object’s `logs` field."""
  logs: StringFilter

  """Filter by the object’s `rolledBackAt` field."""
  rolledBackAt: DatetimeFilter

  """Filter by the object’s `startedAt` field."""
  startedAt: DatetimeFilter

  """Filter by the object’s `appliedStepsCount` field."""
  appliedStepsCount: IntFilter

  """Checks for all expressions in this list."""
  and: [_PrismaMigrationFilter!]

  """Checks for any expressions in this list."""
  or: [_PrismaMigrationFilter!]

  """Negates the expression."""
  not: _PrismaMigrationFilter
}
